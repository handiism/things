// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: credential.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCredential = `-- name: CreateCredential :one
INSERT INTO "credential"("email", "password")
VALUES ($1, $2)
RETURNING id, name, email, username, password, role_id, created_at, deleted_at
`

type CreateCredentialParams struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

func (q *Queries) CreateCredential(ctx context.Context, arg CreateCredentialParams) (Credential, error) {
	row := q.db.QueryRow(ctx, createCredential, arg.Email, arg.Password)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.RoleID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteCredential = `-- name: DeleteCredential :exec
DELETE
FROM "credential"
WHERE "id" = $1
`

func (q *Queries) DeleteCredential(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCredential, id)
	return err
}

const getCredentialByEmail = `-- name: GetCredentialByEmail :one
SELECT id, name, email, username, password, role_id, created_at, deleted_at
FROM "credential"
WHERE "email" = $1
`

func (q *Queries) GetCredentialByEmail(ctx context.Context, email string) (Credential, error) {
	row := q.db.QueryRow(ctx, getCredentialByEmail, email)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.RoleID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCredentialById = `-- name: GetCredentialById :one
SELECT credential.id, credential.name, credential.email, credential.username, credential.password, credential.role_id, credential.created_at, credential.deleted_at, role.id, role.name
FROM "credential"
         JOIN "role" ON "credential"."id" = "role"."id"
WHERE "credential"."id" = $1
`

type GetCredentialByIdRow struct {
	Credential Credential `json:"credential"`
	Role       Role       `json:"role"`
}

func (q *Queries) GetCredentialById(ctx context.Context, id pgtype.UUID) (GetCredentialByIdRow, error) {
	row := q.db.QueryRow(ctx, getCredentialById, id)
	var i GetCredentialByIdRow
	err := row.Scan(
		&i.Credential.ID,
		&i.Credential.Name,
		&i.Credential.Email,
		&i.Credential.Username,
		&i.Credential.Password,
		&i.Credential.RoleID,
		&i.Credential.CreatedAt,
		&i.Credential.DeletedAt,
		&i.Role.ID,
		&i.Role.Name,
	)
	return i, err
}

const getCredentialByUsername = `-- name: GetCredentialByUsername :one
SELECT id, name, email, username, password, role_id, created_at, deleted_at
FROM "credential"
WHERE "username" = $1
`

func (q *Queries) GetCredentialByUsername(ctx context.Context, username pgtype.Text) (Credential, error) {
	row := q.db.QueryRow(ctx, getCredentialByUsername, username)
	var i Credential
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Email,
		&i.Username,
		&i.Password,
		&i.RoleID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getCredentials = `-- name: GetCredentials :many
SELECT id, name, email, username, password, role_id, created_at, deleted_at
FROM "credential"
`

func (q *Queries) GetCredentials(ctx context.Context) ([]Credential, error) {
	rows, err := q.db.Query(ctx, getCredentials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Credential{}
	for rows.Next() {
		var i Credential
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Email,
			&i.Username,
			&i.Password,
			&i.RoleID,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCredential = `-- name: UpdateCredential :exec
UPDATE "credential"
SET "name" = $2 , "email" = $2 , "username" = $3 , "role_id" = $4
WHERE "id" = $1
`

type UpdateCredentialParams struct {
	ID       pgtype.UUID `json:"id"`
	Name     pgtype.Text `json:"name"`
	Username pgtype.Text `json:"username"`
	RoleID   int32       `json:"roleId"`
}

func (q *Queries) UpdateCredential(ctx context.Context, arg UpdateCredentialParams) error {
	_, err := q.db.Exec(ctx, updateCredential,
		arg.ID,
		arg.Name,
		arg.Username,
		arg.RoleID,
	)
	return err
}
